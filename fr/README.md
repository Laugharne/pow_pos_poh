![](assets/pow_pos_poh.png)


# PoW, PoS, PoH : Un guide simple des m√©canismes de consensus blockchain


> **Note :** Les extraits de code dans cet article sont utilis√©s √† des fins d'illustration et repr√©sentent des versions **simplifi√©es** des algorithmes afin de faciliter leur compr√©hension.

## TL;DR

1. Le m√©canisme de consensus est un proc√©d√© par lequel les n≈ìuds d'un r√©seau pair √† pair se mettent d'accord sur un ensemble d'informations.
2. Le choix des algorithmes a des implications sur la s√©curit√©, la d√©centralisation, la consommation √©nerg√©tique et divers aspects d'une blockchain.
3. L'horodatage est un m√©canisme qui permet d'associer une valeur temporelle √† un √©v√©nement.
4. La PoH n'est pas un algorithme de consensus, mais une "*horloge avant consensus*".



## Introduction

Les m√©canismes de **consensus** permettent de se mettre d'accord sur une **version commune et unique** des donn√©es partag√©es par une blockchain et ce malgr√© la possible pr√©sence de n≈ìuds **d√©faillants** ou **malicieux**.

Les principaux r√¥les des m√©canismes de consensus sont les suivants :
1. **Obtenir un accord sur l'√©tat partag√© :** Prouver que les transactions sont valides, leurs ordres, leurs origines.
2. **R√©sister aux d√©faillances :** Le r√©seau doit fonctionner correctement m√™me en pr√©sence de [n≈ìuds d√©fectueux ou malveillants](https://fr.wikipedia.org/wiki/Probl%C3%A8me_des_g%C3%A9n%C3%A9raux_byzantins) (üá´üá∑).
3. **D√©centraliser :** Cela permet une r√©sistance accrue √† la censure et √† la n√©cessit√© d'une autorit√© centrale.
4. **S√©curiser :** Veiller √† l'int√©grit√© des donn√©es, pr√©server des alt√©rations et assurer l'unicit√©.

Ils doivent aussi r√©soudre les enjeux majeurs des r√©seaux distribu√©s, comme la double d√©pense. Le **solde** et l'**√©tat** du r√©seau se doivent √™tre **synchronis√©s**.

Voici trois parmi les principales m√©thodes en vigueur :
- La **preuve de travail** (*proof of work*) utilis√©e pour le **Bitcoin**.
- La **preuve d'enjeu** (*proof of stake*) utilis√©e maintenant par **Ethereum**.
- La **preuve d'historique** (*proof of history*) pr√©sente sur **Solana**. (*PoS en fait, la PoH s'y rajoute, mais on y reviendra plus tard*).



## ‚öíÔ∏è Proof of Work (PoW)

La preuve de travail est la m√©thode de consensus utilis√©e dans **Bitcoin**, [**SHA-256**](https://fr.wikipedia.org/wiki/SHA-2#SHA-256) (üá´üá∑) y est utilis√© pour cr√©er l‚Äôempreinte num√©rique d‚Äôun document (le timestamp est int√©gr√© au hash). Pour chaque bloc, un n≈ìud doit trouver une solution √† un "*puzzle*" math√©matique qui d√©pend du contenu du bloc et de son pr√©c√©dent, [comme illustr√© ici](https://andersbrownworth.com/blockchain/blockchain) (üá¨üáß).


### La difficult√© de calcul

Entre en jeu la notion de [difficult√© de calcul](https://en.bitcoin.it/wiki/Difficulty) (üá¨üáß) qui consiste en un nombre variable et minimal de z√©ros √† obtenir en d√©but de r√©sultat de hash (*leading zeros*) avec l'usage d'un *nonce* incr√©mental dans les it√©rations de calcul. Cette [difficult√© est ajust√©e](https://www.blockchain.com/explorer/charts/difficulty) (üá¨üáß) tous les **2016 blocs** (environs deux semaines) de mani√®re √† conserver un temps moyen entre chaque bloc en dessous de **10 minutes**.

Le premier n≈ìud √† r√©soudre correctement le calcul est r√©compens√© par un certain nombre de bitcoins. Les n≈ìuds vont essayer de trouver cette solution en utilisant leur puissance de calcul. Le temps n√©cessaire pour trouver la solution peut varier, mais il y aura toujours un gagnant d‚Äôune quantit√© de Bitcoins.

Notez qu‚Äôil n‚Äôy a pas de limite de nombre de participants et nul ne peut dire qui va arriver en premier.

Initialement, la r√©compense √©tait de 50 bitcoins par bloc min√©, mais cela se r√©duit de moiti√© approximativement tous les quatre ans dans un √©v√©nement connu sous le nom de ["**halving**"](https://bitbo.io/halving/) (üá¨üáß).

Au prochain halving (*article √©crit d√©but 2024*) qui aura lieu **mi avril 2024**, la r√©compense passera de **6,25 BTC** √† **3,125 BTC** par bloc. 


![](assets/halving.png)

(*source : [bitbo.io](https://buybitcoinworldwide.com/halving/)*)

Chaque halving r√©duit le taux d'inflation du Bitcoin. La **ligne orange** repr√©sente le **taux d'inflation** du Bitcoin pendant une p√©riode donn√©e, tandis que la **ligne bleue** repr√©sente le nombre total de **bitcoins √©mis**.


**Version simplifi√©e du minage (PoW) en Rust :**

```rust
fn mining_block(previous_block_hash: String, current_transactions: &Block, difficulty: usize) -> (String, u32) {
    let prefix: String = "0".repeat(difficulty);
    let mut nonce: u32 = 0;

    loop {
        let to_hash: String    = format!("{}{}{}{}", previous_block_hash, current_transactions.index, current_transactions.data, nonce);
        let block_hash: String = digest(to_hash);
        
        if block_hash.starts_with(&prefix) {
            return (block_hash, nonce);
        } else {
            nonce += 1;
        }
    }
}
```

> Sur une courte s√©quence de **5 blocs**, ma simulation de calcul a d√ª proc√©der √† **370894 calculs de hashs** avant de les valider tous.


## üí∞ Proof of Stake (PoS)

La preuve d‚Äôenjeu est une alternative √† la preuve de travail. **Ethereum** se sert de [SHA-3](https://fr.wikipedia.org/wiki/SHA-3) pour cr√©er l‚Äôempreinte num√©rique. Contrairement √† Bitcoin, o√π les participants (*mineurs*) r√©solvent des probl√®mes complexes pour ajouter un bloc √† la blockchain, la PoS requiert des efforts informatiques consid√©rablement moins intensifs.

Les participants (*validateurs*) sont choisis pour ajouter un nouveau bloc.  Ces validateurs doivent **mettre en jeu** √† **stacker** une quantit√© de cryptomonnaie en tant que garantie, ils seront soit r√©compens√©s (jetons, frais de transaction) pour leur travail, soit [p√©nalis√©s en cas de malveillance](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#pos-and-security) (üá¨üáß).

Le m√©canisme des validateurs est d√©termin√© par leur **enjeu** et il n'y a ainsi donc pas de n√©cessit√© √† r√©soudre des probl√®mes math√©matiques complexes. Par cons√©quent, la difficult√© de recherche de *leading zeros* n'a pas de sens avec ce consensus.


### La carotte et le baton

L'id√©e fondamentale √©tant que les individus/entit√©s qui ont un **int√©r√™t financier** dans la stabilit√© et la s√©curit√© du r√©seau sont moins susceptibles de se comporter de mani√®re malveillante. Leur participation au consensus est bas√©e sur la possession d'une quantit√© de cryptomonnaie mise en jeu plut√¥t que sur la puissance de calcul. Sur Ethereum la somme en jeu est de **32 ETH** par n≈ìud.


**Version simplifi√©e de cr√©ation de bloc (PoS) en Rust :**

```rust
fn creation_block(previous_block_hash: String, current_transactions: &Block) -> String {
    let to_hash: String    = format!("{}{}{}", previous_block_hash, current_transactions.index, current_transactions.data);
    let block_hash: String = digest(to_hash);
    block_hash
}
```

> Sur la m√™me s√©quence de **5 blocs** que pr√©c√©demment, il ne m'a fallu calculer que **5 hashs** pour les valider tous.


## üìú Proof of History (PoH)

En 2008, **Satoshi Nakamoto**, dans son **["White paper"](https://bitcoin.org/bitcoin.pdf)** (üá¨üáß) a introduit le concept de "**timestamp server**". Bien qu'il n'utilise pas explicitement le terme "*blockchain*" dans ce document, il d√©crit les principes fondamentaux qui sous-tendent la technologie blockchain. Le "*timestamp server*" √©tait un √©l√©ment cl√© pour s√©curiser l'ordre chronologique des transactions dans le syst√®me Bitcoin.

> Le terme "*blockchain*" par la suite, est devenu plus couramment utilis√© pour d√©crire la structure de donn√©es d√©centralis√©e qui enregistre de mani√®re immuable les transactions au travers de blocs connect√©s les uns aux autres √† l'aide de fonctions cryptographiques de hachage.

Comme dit dans l'introduction, la synchronisation des √©tats est essentiel pour les blockchains, or celles-ci n'utilisent pas de solution centralis√©e, comme des horloges atomiques, pour r√©soudre leur probl√®me d'unicit√© de temps.

La **preuve d'historique** (*Proof of history : PoH*) est un m√©canisme utilis√© par la blockchain **Solana** qui permet la synchronisation des √©v√©nements de mani√®re tr√®s performante. Elle se trouve ainsi combin√©e avec la *Proof of Stake*. Reposant sur une base de donn√©es distribu√©e appel√©e *Account State*. Chaque transaction est stock√©e dans cette base de donn√©es. Pour qu'elles soient accept√©es, elles doivent √™tre li√©es √† une **transaction pr√©c√©dente** existante. La validation d'une transaction pr√©c√©dente implique la validation des suivantes.

La PoH est une sorte d'**horloge avant consensus** (*Clock before consensus*) qui permet de prouver l'√©coulement du temps entre deux √©v√©nements. Les n≈ìuds n'ont pas √† attendre d'√™tre tous coordonn√©s au niveau de l'horodatage, d√®s qu'un √©v√©nement arrive, il est impossible de placer ceux se produisant apr√®s, avant celui-ci.

En prenant un exemple simple, imaginez un **escalier**, pour en atteindre le haut, il faut d'abord gravir la premi√®re marche, puis la suivante, etc., jusqu'√† atteindre la marche finale. La preuve d'historique garantit la validit√© de chaque transaction encha√Ænant la sienne √† la pr√©c√©dente.


### Comment valider ce passage du temps num√©rique ?

Toujours en reprenant la m√©taphore des escaliers, imaginons un hash √† chaque marche (*ou √©tape*). Le premier √©tage correspond au temps z√©ro et le dernier √©tage correspond au temps actuel ; on ne peut monter sur une marche que si on a mont√© la pr√©c√©dente. On ne peut donc avoir qu'une valeur de sortie donn√©e (*marche courante*) pour une valeur d'entr√©e (*la marche pr√©c√©dente*).

La PoS ajoute un registre d'historique des transactions et des blocs √† chaque n≈ìud. Cela permet aux utilisateurs de v√©rifier si leurs transactions ont √©t√© incluses dans le r√©seau ou pas.

La fonction utilis√©e pour cr√©er ce registre est appel√©e **(High Frequency) Verifiable Delay Function** ou **VDF**.


### Verifiable Delay Function (VDF) ‚è≤Ô∏è

Le VDF g√©n√®re un r√©sultat **unique et v√©rifiable**, par son ex√©cution permanente, plusieurs milliers de fois par seconde. Sa caract√©ristique fondamentale r√©side dans l'impossibilit√© de pr√©dire le r√©sultat sans ex√©cuter la fonction, conf√©rant ainsi une garantie de s√©curit√©.  

Cette fonctionnalit√© trouve son utilit√© dans la capacit√© √† placer un √©v√©nement de mani√®re pr√©cise, avant ou apr√®s un autre, renfor√ßant ainsi la robustesse de diverses applications blockchain et protocoles de consensus.

![](assets/timestamps.png)

*(Pour reprendre l'exemple de l'escalier, chaque "marche" a √©t√© gravie √† un temps donn√©)*

Le processus fonctionne en boucle, g√©n√©rant un hash (*SHA256*) √† chaque it√©ration. √Ä chaque "tour" de fonction, le hash de sortie est r√©utilis√© en tant qu'entr√©e, cr√©ant une cha√Æne continue de hachages. Le r√©sultat de sortie est associ√© √† un nombre d√©fini, le d√©compte (*count*) ce r√©sultat est enregistr√© p√©riodiquement !

Ce qui nous assure que l'ordre enregistr√© pour chaque compteur est le m√™me que celui qui s'est d√©roul√© en temps r√©el.

Il est crucial de noter que le hash est r√©sistant aux attaques de pr√©image (["preimage resistant"](https://fr.wikipedia.org/wiki/Attaque_de_pr%C3%A9image) üá´üá∑), ce qui signifie qu'il est impossible de d√©duire la valeur d'entr√©e √† partir de la valeur de sortie.

Son ex√©cution est :
- Atomique.
- Non parall√©lisable, s'ex√©cute sur un seul c≈ìur de **CPU**.
- Configur√©e pour maintenir une vitesse d'ex√©cution homog√®ne entre les n≈ìuds. [(*ticks, slots, epochs* üá´üá∑)](https://cryptoast.fr/solana-sol-blockchain-atypique-grandes-ambitions/#De_quoi_est_composee_larchitecture_technologique_de_Solana)

Offrant ainsi une protection contre les calculs effectu√©s par des **ASICs**. Cela garantit √©galement un minimum de fiabilit√© pour le d√©compte du temps. En outre, le hash des donn√©es, telles que les transactions, est ajout√© au dernier √©tat g√©n√©r√©. L'√©tat, les donn√©es d'entr√© et le d√©compte sont ensuite publi√©s, assurant un horodatage directement encod√© dans les messages de transaction.

![](assets/insertion.png)

*(Enregistrement de messages dans une s√©quence de Preuve d'Historique)*

Il est important de noter que le PoH ne garantit pas la chronologie absolue des transactions, mais uniquement leur **ordonnancement relatif**. Cela signifie qu'une transaction peut arriver apr√®s une autre m√™me si elle est ant√©rieure.

> **Preuve d'ordonnancement** pourrait aussi √™tre un terme valable pour la PoH.

Les donn√©es ins√©r√©es dans la PoH font r√©f√©rence aux pr√©c√©dentes  (`last_hash`). Les donn√©es entrantes sont ainsi auto-r√©f√©renci√©es. Elle est incorpor√©e en tant que partie du message, sign√© avec une clef priv√©e lors de l'insertion, garantissant ainsi qu'elle ne peut pas √™tre modifi√©e sans la cl√© priv√©e. 

![](assets/back_ref.png)

Et c'est parce que le message contient le hash `0xdeadc0de`, que nous savons qu'il a √©t√© g√©n√©r√© apr√®s la cr√©ation du d√©compte `510144806912`.


**Voici un exemple de code simplifi√© en Rust qui illustre un m√©canisme de "Verifiable Delay Function" (VDF) :**

```rust
use sha256::digest;

const PERIOD: u64 = 1000;

struct VDFState {
    hash : String,
    count: u64,
}

impl VDFState {

    fn new() -> VDFState {
        VDFState {
            hash : String::new(),
            count: 0,
        }
    }

    fn execute(&mut self, data: &str) {
        self.hash   = digest(format!("{}{}", self.hash, data));
        self.count += 1;

        // Periodically check for the desired output
        if self.count % PERIOD != 0 { return;}
        self.output();
    }

    // Publish the hash, count, and other relevant data.
    fn output(&self) {
        // Must perform additional checks on the current state.
        println!("Hash: {}, Count: {}", self.hash, self.count);
    }

}

fn main() {
    let mut vdf = VDFState::new();

    // VDF simulation in a loop with new data (transactions).
    for _ in 0..10000 {
        let transaction_data = "Transaction Data"; // Replace with actual transaction data
        vdf.execute(transaction_data);
    }
}
```

Vous pouvez remplacer "*Transaction Data*" par les donn√©es r√©elles que vous souhaitez inclure dans le calcul du hash. Cet exemple n'inclut pas toutes les v√©rifications de s√©curit√©, mais il donne une id√©e g√©n√©rale du fonctionnement d'un VDF dans un environnement de blockchain.

> **ENCORE UNE FOIS**, ce n'est qu'une **illustration simplifi√©e**.

Le choix de la valeur de `PERIOD` d√©pend des exigences sp√©cifiques du syst√®me, y compris la tol√©rance au temps, la s√©curit√© souhait√©e et les ressources disponibles. Il est √† d√©terminer par des consid√©rations de conception sp√©cifiques √† votre cas d'utilisation.


### Des v√©rifications parall√®les üöÄ

√ânorme avantage du m√©canisme de la PoH, la v√©rification des preuves peut √™tre effectu√©e en parall√®le, tandis que leur cr√©ation ne peut pas l'√™tre (*VDF oblige*). Cela permet une fragmentation et une distribution efficace des t√¢ches entre les diff√©rents c≈ìurs d'un processeur, CPU ou [GPU](https://docs.solanalabs.com/operations/guides/validator-start) (üá¨üáß).

![](assets/verifications.png)

*(v√©rifications en parall√®le)*

Les horodatages pr√©cis, fournis par la Proof of History, permettent aux n≈ìuds de travailler de mani√®re ind√©pendante sur plusieurs blocs en m√™me temps, sans √™tre bloqu√©s par des d√©pendances temporelles.

La preuve devra contenir chaque hash interm√©diaire, puis chaque calcul de hash interm√©diaire pourra √™tre v√©rifi√© en parall√®le.

- **L'avantage** r√©side dans les performances, car cela r√©duit les surco√ªts dans les √©changes de messages et la latence en fournissant un ordre de transaction pr√©d√©termin√©.
- **L'inconv√©nient** de cela est une taille de preuve tr√®s importante et des **[exigences mat√©rielles](https://docs.solana.com/running-validator/validator-reqs)** (üá¨üáß) g√©n√©ralement √©lev√©es pour les validateurs.


**Version simplifi√©e de la v√©rification de bloc (PoH) en Rust :**

```rust
// la biblioth√®que (crate) `rayon` https://crates.io/crates/rayon
// est utilis√©e pour parall√®liser les v√©rifications des messages.
use rayon::prelude::*;

// ...

block_chain.par_iter().for_each(|block| {
    par_verification(block);
});

post_synchro(&block_chain);
```

```rust
// Crate `rayon` https://crates.io/crates/rayon
// is used to parallelize messages verification.
use rayon::prelude::*;

fn par_verification(block: &Block, previous_block: &Block) -> Result<(), &'static str> {
    // Check if previous block hash is equal to current block hash.
    if block.previous_block_hash != previous_block.hash {
        return Err("Previous block hash don't match.");
    }

    if block.time_stamp <=  previous_block.time_stamp {
        return Err("Invalid timestamp.");
    }

    // Check if current block content is coherent.
    if !block.check_validity()  {
        return Err("Current block state is not valide.");
    }

    Ok(())
}

// Verify all blocks in the blockchain in parallel.
let results: Vec<Result<(), &'static str>> = block_chain
    .par_windows(2)  // windows of two consecutives blocks.
    .map(|window| par_verification(&window[1], &window[0]))
    .collect();

// Check for all verifications success.
if results.into_iter().all(|result| result.is_ok()) {
    post_synchro(&block_chain);
} else {
    // At least one fail.
    // ...
}
```

√Ä Noter que la **Proof of History** en tant que telle ne garantit pas √† elle seule la s√©curit√© du r√©seau contre les attaques malveillantes, que ce soit **[l‚Äôattaque des 51%](https://coinacademy.fr/academie/quest-une-attaque-51-quelles-consequences/)** (üá´üá∑), **[des 34%](https://www.linkedin.com/pulse/34-attack-smocking-art/)** (üá´üá∑) ou **[l‚Äôattaque "Sybil"](https://coinacademy.fr/academie/attaque-sybil-attack-blockchain-noeud/)** (üá´üá∑). C‚Äôest pourquoi elle est coupl√©e avec la Proof of Stake sur **Solana**, ce qui permet de r√©gler le probl√®me.


## Conclusion

Les m√©canismes de consensus, jouent un r√¥le crucial dans le fonctionnement des blockchains. Chacun de ces m√©canismes pr√©sente des caract√©ristiques distinctes, influen√ßant la s√©curit√©, la d√©centralisation, les performances et la consommation √©nerg√©tique d'une blockchain.

Tous essaient de r√©soudre la probl√©matique qui consiste √† concevoir un protocole permettant √† un ensemble de processus de s'accorder sur des √©tats/valeurs uniques, tout en √©tant r√©sistant aux d√©faillances et malveillances.



--------

Cr√©dits : **[Franck Maussand](mailto:franck@maussand.net)**

*Merci √† [Igor Bournazel](https://github.com/ibourn) pour la relecture de cet article.*

N'h√©sitez pas √† jeter un coup d'oeil sur mon pr√©c√©dent article sur le [**function dispatcher des EVM**](https://medium.com/@franck.maussand/optimisation-sur-ethereum-faites-la-diff%C3%A9rence-avec-les-noms-de-fonctions-ba4692c9e39f) (üá´üá∑) !

--------


## Ressources additionnelles

- üá¨üáß [The Energy Footprint of Blockchain Consensus
Mechanisms Beyond Proof-of-Work](https://arxiv.org/pdf/2109.03667)

- **Blockchains :**
  - üá¨üáß [Bitcoin - Open source P2P money](https://bitcoin.org)
  - üá¨üáß [Home | ethereum.org](https://ethereum.org)
  - üá¨üáß [Web3 Infrastructure for Everyone | Solana](https://solana.com/)

- **Probl√®me des g√©n√©raux byzantins :**
  - üá´üá∑ [Probl√®me des g√©n√©raux byzantins ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/Probl%C3%A8me_des_g%C3%A9n%C3%A9raux_byzantins)
  - üá¨üáß [Byzantine fault - Wikipedia](https://en.wikipedia.org/wiki/Byzantine_fault)

- **Hash :**
  - üá´üá∑ [Fonction de hachage ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/Fonction_de_hachage)
  - üá¨üáß [Hash function - Wikipedia](https://en.wikipedia.org/wiki/Hash_function)
  - üá´üá∑ [SHA-2 ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/SHA-2#SHA-256)
  - üá¨üáß [SHA-2 - Wikipedia](https://en.wikipedia.org/wiki/SHA-2)
  - üá´üá∑ [SHA-3 ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/SHA-3)
  - üá¨üáß [SHA-3 - Wikipedia](https://en.wikipedia.org/wiki/SHA-3)
  - üá¨üáß [Blockchain Demo - Hash](https://andersbrownworth.com/blockchain/hash)

- **Attaques :**
  - üá´üá∑ [Attaque des 51 %](https://fr.wikipedia.org/wiki/Attaque_des_51_%25)
  - üá´üá∑ [Attaque Sybil](https://fr.wikipedia.org/wiki/Attaque_Sybil)
  - üá´üá∑ [Qu‚Äôest-ce qu‚Äôune attaque Sybil (Sybil attack) ?](https://coinacademy.fr/academie/attaque-sybil-attack-blockchain-noeud/)
  - üá´üá∑ [Qu‚Äôest-ce qu‚Äôune attaque 51% et quelles sont ses cons√©quences ?](https://coinacademy.fr/academie/quest-une-attaque-51-quelles-consequences/)
  - üá¨üáß [Ethereum PoS Attack and Defense ‚Äî jmc](https://mirror.xyz/jmcook.eth/YqHargbVWVNRQqQpVpzrqEQ8IqwNUJDIpwRP7SS5FXs)
  - üá¨üáß / üá´üá∑ [34% Attack](https://www.linkedin.com/pulse/34-attack-smocking-art/)
  - üá¨üáß [Double-spending ‚Äî 51% attack](https://en.wikipedia.org/wiki/Double-spending#51%_attack)
  - üá¨üáß [Sybil attack](https://en.wikipedia.org/wiki/Sybil_attack)
  - üá´üá∑ [Attaque de pr√©image ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/Attaque_de_pr%C3%A9image)
  - üá¨üáß [Preimage attack - Wikipedia](https://en.wikipedia.org/wiki/Preimage_attack)


- **PoW :**
  - üá´üá∑ [Bitcoin : un syst√®me de paiement √©lectronique pair-√†-pair](https://bitcoin.org/files/bitcoin-paper/bitcoin_fr.pdf)
  - üá¨üáß ["Bitcoin: A Peer-to-Peer Electronic Cash System"](https://bitcoin.org/bitcoin.pdf)
  - üá¨üáß [Blockchain Demo - Blockchain](https://andersbrownworth.com/blockchain/blockchain)
  - üá¨üáß [What is Proof of Work? (Cryptocurrency Explanation)](https://www.youtube.com/watch?v=XLcWy1uV8YM)
  - üá¨üáß [Blockchain.com | Charts - Network Difficulty](https://www.blockchain.com/explorer/charts/difficulty)
  - üá¨üáß [Difficulty - Bitcoin Wiki](https://en.bitcoin.it/wiki/Difficulty)
  - üá¨üáß [Next Bitcoin Halving 2024 Date & Countdown [BTC Clock]](https://bitbo.io/halving/)


- **PoS :**
  - üá´üá∑ [Proof of work / Proof of Stake : C'est quoi la diff√©rence ?](https://www.youtube.com/watch?v=dEGcAXeQsns)
  - üá¨üáß [Proof-of-stake (PoS) | ethereum.org](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)
  - üá¨üáß [Proof-of-stake and security](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#pos-and-security)
  - üá¨üáß [What is Proof of Stake & How Does Confirmation Work in PoS?](https://coindcx.com/blog/crypto-basics/what-is-proof-of-stake-pos/)
  - üá¨üáß [The Beacon Chain Ethereum 2.0 explainer you need to read first | ethos.dev](https://ethos.dev/beacon-chain)


- **PoH :**
  - üá´üá∑ [De quoi est compos√©e l‚Äôarchitecture technologique de Solana ?](https://cryptoast.fr/solana-sol-blockchain-atypique-grandes-ambitions/#De_quoi_est_composee_larchitecture_technologique_de_Solana)
  - üá¨üáß [Proof of History: How Solana brings time to crypto | Solana](https://solana.com/news/proof-of-history)
  - üá¨üáß [Solana: A new architecture for a high performance blockchain](https://solana.com/solana-whitepaper.pdf)
  - üá¨üáß [Break | Solana](https://break.solana.com/)
  - üá¨üáß [Proof of History: A Clock for Blockchain by Anatoly Yakovenko](https://medium.com/solana-labs/proof-of-history-a-clock-for-blockchain-cf47a61a9274)
  - üá¨üáß [Proof of History Explained by a Water Clock](https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8)
  - üá¨üáß [Joachim Neu ‚Äî The Why and How of PoS Ethereum's Consensus Problem (ETHconomics @ Devconnect 2022) - YouTube](https://www.youtube.com/watch?v=2nMS-TK_tMw)
  - üá¨üáß [GitHub - ethereum/annotated-spec: Vitalik's annotated eth2 spec.](https://github.com/ethereum/annotated-spec)


- **VDF :**
  - üá¨üáß [Timelock Puzzles Using VDFs](https://medium.com/mistywest/timelock-puzzles-using-vdfs-b5636503950d)
  - üá¨üáß [Day 54: VDFs: Verifiable Delay Functions in Blockchain](https://gsoares-block.medium.com/day-54-vdfs-verifiable-delay-functions-in-blockchain-addb3d89a72b)
  - üá¨üáß [Verifiable Delay Functions](https://www.youtube.com/watch?v=_-feyaZZjEw)
  - üá¨üáß [Verifiable Delay Functions: Applications and Candidate Constructions - BPASE '18](https://www.youtube.com/watch?v=qUoagL7OZ1k)
  - üá¨üáß [Verifiable Delayed Functions I - CANARI](https://canari.math.u-bordeaux.fr/seminar/ciao-2020-02-04-1400-BenjaminWesolowski.pdf)
  - üá¨üáß [Verifiable Delay Functions - A brief and gentle introduction](https://medium.com/iovlabs-innovation-stories/verifiable-delay-functions-8eb6390c5f4)


- **Hardware Requirements for Solana :**
  - üá¨üáß [Validator Requirements | Solana Docs](https://docs.solana.com/running-validator/validator-reqs)
  - üá¨üáß [Solana Nodes - The Complete Guide (2023)](https://www.alchemy.com/overviews/solana-nodes)
  - üá¨üáß [Starting a Validator (Enabling CUDA)](https://docs.solanalabs.com/operations/guides/validator-start)

